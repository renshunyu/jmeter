"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.catalina.startup;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\n\nimport jakarta.servlet.MultipartConfigElement;\nimport jakarta.servlet.ServletContainerInitializer;\nimport jakarta.servlet.ServletContext;\nimport jakarta.servlet.SessionCookieConfig;\nimport jakarta.servlet.annotation.HandlesTypes;\n\nimport org.apache.catalina.Authenticator;\nimport org.apache.catalina.Container;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Engine;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Host;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleEvent;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Pipeline;\nimport org.apache.catalina.Server;\nimport org.apache.catalina.Service;\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.WebResource;\nimport org.apache.catalina.WebResourceRoot;\nimport org.apache.catalina.Wrapper;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.core.StandardHost;\nimport org.apache.catalina.util.ContextName;\nimport org.apache.catalina.util.Introspection;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.apache.tomcat.Jar;\nimport org.apache.tomcat.JarScanType;\nimport org.apache.tomcat.JarScanner;\nimport org.apache.tomcat.util.ExceptionUtils;\nimport org.apache.tomcat.util.bcel.classfile.AnnotationElementValue;\nimport org.apache.tomcat.util.bcel.classfile.AnnotationEntry;\nimport org.apache.tomcat.util.bcel.classfile.ArrayElementValue;\nimport org.apache.tomcat.util.bcel.classfile.ClassFormatException;\nimport org.apache.tomcat.util.bcel.classfile.ClassParser;\nimport org.apache.tomcat.util.bcel.classfile.ElementValue;\nimport org.apache.tomcat.util.bcel.classfile.ElementValuePair;\nimport org.apache.tomcat.util.bcel.classfile.JavaClass;\nimport org.apache.tomcat.util.buf.UriUtil;\nimport org.apache.tomcat.util.descriptor.InputSourceUtil;\nimport org.apache.tomcat.util.descriptor.XmlErrorHandler;\nimport org.apache.tomcat.util.descriptor.web.ContextEjb;\nimport org.apache.tomcat.util.descriptor.web.ContextEnvironment;\nimport org.apache.tomcat.util.descriptor.web.ContextLocalEjb;\nimport org.apache.tomcat.util.descriptor.web.ContextResource;\nimport org.apache.tomcat.util.descriptor.web.ContextResourceEnvRef;\nimport org.apache.tomcat.util.descriptor.web.ContextService;\nimport org.apache.tomcat.util.descriptor.web.ErrorPage;\nimport org.apache.tomcat.util.descriptor.web.FilterDef;\nimport org.apache.tomcat.util.descriptor.web.FilterMap;\nimport org.apache.tomcat.util.descriptor.web.FragmentJarScannerCallback;\nimport org.apache.tomcat.util.descriptor.web.JspPropertyGroup;\nimport org.apache.tomcat.util.descriptor.web.LoginConfig;\nimport org.apache.tomcat.util.descriptor.web.MessageDestinationRef;\nimport org.apache.tomcat.util.descriptor.web.MultipartDef;\nimport org.apache.tomcat.util.descriptor.web.SecurityConstraint;\nimport org.apache.tomcat.util.descriptor.web.SecurityRoleRef;\nimport org.apache.tomcat.util.descriptor.web.ServletDef;\nimport org.apache.tomcat.util.descriptor.web.SessionConfig;\nimport org.apache.tomcat.util.descriptor.web.WebXml;\nimport org.apache.tomcat.util.descriptor.web.WebXmlParser;\nimport org.apache.tomcat.util.digester.Digester;\nimport org.apache.tomcat.util.digester.RuleSet;\nimport org.apache.tomcat.util.file.ConfigFileLoader;\nimport org.apache.tomcat.util.file.ConfigurationSource;\nimport org.apache.tomcat.util.res.StringManager;\nimport org.apache.tomcat.util.scan.JarFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Startup event listener for a <b>Context</b> that configures the properties\n * of that Context, and the associated defined servlets.\n *\n * @author Craig R. McClanahan\n */\npublic class ContextConfig implements LifecycleListener {\n\n    private static final Log log = LogFactory.getLog(ContextConfig.class);\n\n    /**\n     * The string resources for this package.\n     */\n    protected static final StringManager sm =\n        StringManager.getManager(Constants.Package);\n\n\n    protected static final LoginConfig DUMMY_LOGIN_CONFIG =\n        new LoginConfig(\"NONE\", null, null, null);\n\n\n    /**\n     * The set of Authenticators that we know how to configure.  The key is\n     * the name of the implemented authentication method, and the value is\n     * the fully qualified Java class name of the corresponding Valve.\n     */\n    protected static final Properties authenticators;\n\n    static {\n        // Load our mapping properties for the standard authenticators\n        Properties props = new Properties();\n        try (InputStream is = ContextConfig.class.getClassLoader().getResourceAsStream(\n                \"org/apache/catalina/startup/Authenticators.properties\")) {\n            if (is != null) {\n                props.load(is);\n            }\n        } catch (IOException ioe) {\n            props = null;\n        }\n        authenticators = props;\n    }\n\n    /**\n     * Deployment count.\n     */\n    protected static long deploymentCount = 0L;\n\n\n    /**\n     * Cache of default web.xml fragments per Host\n     */\n    protected static final Map<Host,DefaultWebXmlCacheEntry> hostWebXmlCache =\n            new ConcurrentHashMap<>();\n\n\n    /**\n     * Set used as the value for {@code JavaClassCacheEntry.sciSet} when there\n     * are no SCIs associated with a class.\n     */\n    private static final Set<ServletContainerInitializer> EMPTY_SCI_SET = Collections.emptySet();\n\n\n    // ----------------------------------------------------- Instance Variables\n    /**\n     * Custom mappings of login methods to authenticators\n     */\n    protected Map<String,Authenticator> customAuthenticators;\n\n\n    /**\n     * The Context we are associated with.\n     */\n    protected volatile Context context = null;\n\n\n    /**\n     * The default web application's deployment descriptor location.\n     */\n    protected String defaultWebXml = null;\n\n\n    /**\n     * Track any fatal errors during startup configuration processing.\n     */\n    protected boolean ok = false;\n\n\n    /**\n     * Original docBase.\n     */\n    protected String originalDocBase = null;\n\n\n    /**\n     * Anti-locking docBase. It is a path to a copy of the web application\n     * in the java.io.tmpdir directory. This path is always an absolute one.\n     */\n    private File antiLockingDocBase = null;\n\n\n    /**\n     * Map of ServletContainerInitializer to classes they expressed interest in.\n     */\n    protected final Map<ServletContainerInitializer, Set<Class<?>>> initializerClassMap =\n            new LinkedHashMap<>();\n\n    /**\n     * Map of Types to ServletContainerInitializer that are interested in those\n     * types.\n     */\n    protected final Map<Class<?>, Set<ServletContainerInitializer>> typeInitializerMap =\n            new HashMap<>();\n\n    /**\n     * Flag that indicates if at least one {@link HandlesTypes} entry is present\n     * that represents an annotation.\n     */\n    protected boolean handlesTypesAnnotations = false;\n\n    /**\n     * Flag that indicates if at least one {@link HandlesTypes} entry is present\n     * that represents a non-annotation.\n     */\n    protected boolean handlesTypesNonAnnotations = false;\n\n\n    // ------------------------------------------------------------- Properties\n\n    /**\n     * Obtain the location of the default deployment descriptor.\n     *\n     * @return The path to the default web.xml. If not absolute, it is relative\n     *         to CATALINA_BASE.\n     */\n    public String getDefaultWebXml() {\n        if (defaultWebXml == null) {\n            defaultWebXml = Constants.DefaultWebXml;\n        }\n        return defaultWebXml;\n    }\n\n\n    /**\n     * Set the location of the default deployment descriptor.\n     *\n     * @param path The path to the default web.xml. If not absolute, it is\n     *             relative to CATALINA_BASE.\n     */\n    public void setDefaultWebXml(String path) {\n        this.defaultWebXml = path;\n    }\n\n\n    /**\n     * Sets custom mappings of login methods to authenticators.\n     *\n     * @param customAuthenticators Custom mappings of login methods to\n     * authenticators\n     */\n    public void setCustomAuthenticators(\n            Map<String,Authenticator> customAuthenticators) {\n        this.customAuthenticators = customAuthenticators;\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * Process events for an associated Context.\n     *\n     * @param event The lifecycle event that has occurred\n     */\n    @Override\n    public void lifecycleEvent(LifecycleEvent event) {\n\n        // Identify the context we are associated with\n        try {\n            context = (Context) event.getLifecycle();\n        } catch (ClassCastException e) {\n            log.error(sm.getString(\"contextConfig.cce\", event.getLifecycle()), e);\n            return;\n        }\n\n        // Process the event that has occurred\n        if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {\n            configureStart();\n        } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {\n            beforeStart();\n        } else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) {\n            // Restore docBase for management tools\n            if (originalDocBase != null) {\n                context.setDocBase(originalDocBase);\n            }\n        } else if (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) {\n            configureStop();\n        } else if (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) {\n            init();\n        } else if (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) {\n            destroy();\n        }\n\n    }\n\n\n    // -------------------------------------------------------- protected Methods\n\n\n    /**\n     * Process the application classes annotations, if it exists.\n     */\n    protected void applicationAnnotationsConfig() {\n\n        long t1=System.currentTimeMillis();\n\n        WebAnnotationSet.loadApplicationAnnotations(context);\n\n        long t2=System.currentTimeMillis();\n        if (context instanceof StandardContext) {\n            ((StandardContext) context).setStartupTime(t2-t1+\n                    ((StandardContext) context).getStartupTime());\n        }\n    }\n\n\n    /**\n     * Set up an Authenticator automatically if required, and one has not\n     * already been configured.\n     */\n    protected void authenticatorConfig() {\n\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            // Need an authenticator to support HttpServletRequest.login()\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null) {\n            return;\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n\n        if (authenticator == null) {\n            if (authenticators == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorResources\"));\n                ok = false;\n                return;\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.getConstructor().newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null) {\n            Pipeline pipeline = context.getPipeline();\n            if (pipeline != null) {\n                pipeline.addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Create (if necessary) and return a Digester configured to process the\n     * context configuration descriptor for an application.\n     * @return the digester for context.xml files\n     */\n    protected Digester createContextDigester() {\n        Digester digester = new Digester();\n        digester.setValidating(false);\n        digester.setRulesValidation(true);\n        Map<Class<?>, List<String>> fakeAttributes = new HashMap<>();\n        List<String> objectAttrs = new ArrayList<>();\n        objectAttrs.add(\"className\");\n        fakeAttributes.put(Object.class, objectAttrs);\n        // Ignore attribute added by Eclipse for its internal tracking\n        List<String> contextAttrs = new ArrayList<>();\n        contextAttrs.add(\"source\");\n        fakeAttributes.put(StandardContext.class, contextAttrs);\n        digester.setFakeAttributes(fakeAttributes);\n        RuleSet contextRuleSet = new ContextRuleSet(\"\", false);\n        digester.addRuleSet(contextRuleSet);\n        RuleSet namingRuleSet = new NamingRuleSet(\"Context/\");\n        digester.addRuleSet(namingRuleSet);\n        return digester;\n    }\n\n\n    protected boolean getGenerateCode() {\n        Catalina catalina = Container.getService(context).getServer().getCatalina();\n        if (catalina != null) {\n            return catalina.getGenerateCode();\n        } else {\n            return false;\n        }\n    }\n\n\n    protected boolean getUseGeneratedCode() {\n        Catalina catalina = Container.getService(context).getServer().getCatalina();\n        if (catalina != null) {\n            return catalina.getUseGeneratedCode();\n        } else {\n            return false;\n        }\n    }\n\n\n    protected File getGeneratedCodeLocation() {\n        Catalina catalina = Container.getService(context).getServer().getCatalina();\n        if (catalina != null) {\n            return catalina.getGeneratedCodeLocation();\n        } else {\n            // Cannot happen\n            return null;\n        }\n    }\n\n\n    protected String getGeneratedCodePackage() {\n        Catalina catalina = Container.getService(context).getServer().getCatalina();\n        if (catalina != null) {\n            return catalina.getGeneratedCodePackage();\n        } else {\n            return \"generatedCodePackage\";\n        }\n    }\n\n\n    protected static String getContextXmlPackageName(String generatedCodePackage, Container container) {\n        StringBuilder result = new StringBuilder();\n        Container host = null;\n        Container engine = null;\n        while (container != null) {\n            if (container instanceof Host) {\n                host = container;\n            } else if (container instanceof Engine) {\n                engine = container;\n            }\n            container = container.getParent();\n        }\n        result.append(generatedCodePackage);\n        if (engine != null) {\n            result.append('.');\n        }\n        if (engine != null) {\n            result.append(engine.getName());\n            if (host != null) {\n                result.append('.');\n            }\n        }\n        if (host != null) {\n            result.append(host.getName());\n        }\n        return result.toString();\n    }\n\n\n    protected File getContextXmlJavaSource(String contextXmlPackageName, String contextXmlSimpleClassName) {\n        File generatedSourceFolder = getGeneratedCodeLocation();\n        String path = contextXmlPackageName.replace('.', File.separatorChar);\n        File packageFolder = new File(generatedSourceFolder, path);\n        if (packageFolder.isDirectory() || packageFolder.mkdirs()) {\n            return new File(packageFolder, contextXmlSimpleClassName + \".java\");\n        }\n        return null;\n    }\n\n\n    protected void generateClassHeader(Digester digester, String packageName, String resourceName) {\n        StringBuilder code = digester.getGeneratedCode();\n        code.append(\"package \").append(packageName).append(';').append(System.lineSeparator());\n        code.append(\"public class \").append(resourceName).append(\" implements \");\n        code.append(ContextXml.class.getName().replace('$', '.'));\n        code.append(\" {\").append(System.lineSeparator());\n        code.append(\"public void load(\");\n        code.append(Context.class.getName());\n        String contextArgument = digester.toVariableName(context);\n        code.append(' ').append(contextArgument).append(\") {\").append(System.lineSeparator());\n        // Create a new variable with the concrete type\n        digester.setKnown(context);\n        code.append(context.getClass().getName()).append(' ').append(digester.toVariableName(context));\n        code.append(\" = (\").append(context.getClass().getName()).append(\") \").append(contextArgument);\n        code.append(';').append(System.lineSeparator());\n    }\n\n\n    protected void generateClassFooter(Digester digester) {\n        StringBuilder code = digester.getGeneratedCode();\n        code.append('}').append(System.lineSeparator());\n        code.append('}').append(System.lineSeparator());\n    }\n\n\n    public interface ContextXml {\n        void load(Context context);\n    }\n\n\n    /**\n     * Process the default configuration file, if it exists.\n     * @param digester The digester that will be used for XML parsing\n     */\n    protected void contextConfig(Digester digester) {\n\n        String defaultContextXml = null;\n\n        boolean generateCode = getGenerateCode();\n        boolean useGeneratedCode = getUseGeneratedCode();\n\n        String contextXmlPackageName = null;\n        String contextXmlSimpleClassName = null;\n        String contextXmlClassName = null;\n        File contextXmlJavaSource = null;\n\n        // Open the default context.xml file, if it exists\n        if (context instanceof StandardContext) {\n            defaultContextXml = ((StandardContext)context).getDefaultContextXml();\n        }\n        // set the default if we don't have any overrides\n        if (defaultContextXml == null) {\n            defaultContextXml = Constants.DefaultContextXml;\n        }\n\n        ContextXml contextXml = null;\n\n        if (!context.getOverride()) {\n\n            if (useGeneratedCode || generateCode) {\n                contextXmlPackageName = getGeneratedCodePackage();\n                contextXmlSimpleClassName = \"ContextXmlDefault\";\n                contextXmlClassName = contextXmlPackageName + \".\" + contextXmlSimpleClassName;\n            }\n            if (useGeneratedCode) {\n                contextXml = (ContextXml) Digester.loadGeneratedClass(contextXmlClassName);\n            }\n            if (contextXml != null) {\n                contextXml.load(context);\n                contextXml = null;\n            } else if (!useGeneratedCode) {\n                try (ConfigurationSource.Resource contextXmlResource =\n                        ConfigFileLoader.getSource().getResource(defaultContextXml)) {\n                    if (generateCode) {\n                        contextXmlJavaSource = getContextXmlJavaSource(contextXmlPackageName, contextXmlSimpleClassName);\n                        if (contextXmlJavaSource != null) {\n                            digester.startGeneratingCode();\n                            generateClassHeader(digester, contextXmlPackageName, contextXmlSimpleClassName);\n                        } else {\n                            generateCode = false;\n                        }\n                    }\n                    URL defaultContextUrl = contextXmlResource.getURI().toURL();\n                    processContextConfig(digester, defaultContextUrl, contextXmlResource.getInputStream());\n                    if (generateCode) {\n                        generateClassFooter(digester);\n                        try (FileWriter writer = new FileWriter(contextXmlJavaSource)) {\n                            writer.write(digester.getGeneratedCode().toString());\n                        }\n                        digester.endGeneratingCode();\n                        Digester.addGeneratedClass(contextXmlClassName);\n                    }\n                } catch (MalformedURLException e) {\n                    log.error(sm.getString(\"contextConfig.badUrl\", defaultContextXml), e);\n                } catch (IOException e) {\n                    // Not found\n                }\n            }\n\n            if (useGeneratedCode || generateCode) {\n                contextXmlPackageName = getContextXmlPackageName(getGeneratedCodePackage(), context);\n                contextXmlSimpleClassName = \"ContextXmlDefault\";\n                contextXmlClassName = contextXmlPackageName + \".\" + contextXmlSimpleClassName;\n            }\n            if (useGeneratedCode) {\n                contextXml = (ContextXml) Digester.loadGeneratedClass(contextXmlClassName);\n            }\n            if (contextXml != null) {\n                contextXml.load(context);\n                contextXml = null;\n            } else if (!useGeneratedCode) {\n                String hostContextFile = Container.getConfigPath(context, Constants.HostContextXml);\n                try (ConfigurationSource.Resource contextXmlResource =\n                        ConfigFileLoader.getSource().getResource(hostContextFile)) {\n                    if (generateCode) {\n                        contextXmlJavaSource = getContextXmlJavaSource(contextXmlPackageName, contextXmlSimpleClassName);\n                        digester.startGeneratingCode();\n                        generateClassHeader(digester, contextXmlPackageName, contextXmlSimpleClassName);\n                    }\n                    URL defaultContextUrl = contextXmlResource.getURI().toURL();\n                    processContextConfig(digester, defaultContextUrl, contextXmlResource.getInputStream());\n                    if (generateCode) {\n                        generateClassFooter(digester);\n                        try (FileWriter writer = new FileWriter(contextXmlJavaSource)) {\n                            writer.write(digester.getGeneratedCode().toString());\n                        }\n                        digester.endGeneratingCode();\n                        Digester.addGeneratedClass(contextXmlClassName);\n                    }\n                } catch (MalformedURLException e) {\n                    log.error(sm.getString(\"contextConfig.badUrl\", hostContextFile), e);\n                } catch (IOException e) {\n                    // Not found\n                }\n            }\n        }\n\n        if (context.getConfigFile() != null) {\n            if (useGeneratedCode || generateCode) {\n                contextXmlPackageName = getContextXmlPackageName(getGeneratedCodePackage(), context);\n                contextXmlSimpleClassName = \"ContextXml_\" + context.getName().replace('/', '_').replace(\"-\", \"__\");\n                contextXmlClassName = contextXmlPackageName + \".\" + contextXmlSimpleClassName;\n            }\n            if (useGeneratedCode) {\n                contextXml = (ContextXml) Digester.loadGeneratedClass(contextXmlClassName);\n            }\n            if (contextXml != null) {\n                contextXml.load(context);\n                contextXml = null;\n            } else if (!useGeneratedCode) {\n                if (generateCode) {\n                    contextXmlJavaSource = getContextXmlJavaSource(contextXmlPackageName, contextXmlSimpleClassName);\n                    digester.startGeneratingCode();\n                    generateClassHeader(digester, contextXmlPackageName, contextXmlSimpleClassName);\n                }\n                processContextConfig(digester, context.getConfigFile(), null);\n                if (generateCode) {\n                    generateClassFooter(digester);\n                    try (FileWriter writer = new FileWriter(contextXmlJavaSource)) {\n                        writer.write(digester.getGeneratedCode().toString());\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                    digester.endGeneratingCode();\n                    Digester.addGeneratedClass(contextXmlClassName);\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * Process a context.xml.\n     * @param digester The digester that will be used for XML parsing\n     * @param contextXml The URL to the context.xml configuration\n     * @param stream The XML resource stream\n     */\n    protected void processContextConfig(Digester digester, URL contextXml, InputStream stream) {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Processing context [\" + context.getName()\n                    + \"] configuration file [\" + contextXml + \"]\");\n        }\n\n        InputSource source = null;\n\n        try {\n            source = new InputSource(contextXml.toString());\n            if (stream == null) {\n                URLConnection xmlConn = contextXml.openConnection();\n                xmlConn.setUseCaches(false);\n                stream = xmlConn.getInputStream();\n            }\n        } catch (Exception e) {\n            log.error(sm.getString(\"contextConfig.contextMissing\",\n                      contextXml) , e);\n        }\n\n        if (source == null) {\n            return;\n        }\n\n        try {\n            source.setByteStream(stream);\n            digester.setClassLoader(this.getClass().getClassLoader());\n            digester.setUseContextClassLoader(false);\n            digester.push(context.getParent());\n            digester.push(context);\n            XmlErrorHandler errorHandler = new XmlErrorHandler();\n            digester.setErrorHandler(errorHandler);\n            digester.parse(source);\n            if (errorHandler.getWarnings().size() > 0 ||\n                    errorHandler.getErrors().size() > 0) {\n                errorHandler.logFindings(log, contextXml.toString());\n                ok = false;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Successfully processed context [\" + context.getName()\n                        + \"] configuration file [\" + contextXml + \"]\");\n            }\n        } catch (SAXParseException e) {\n            log.error(sm.getString(\"contextConfig.contextParse\",\n                    context.getName()), e);\n            log.error(sm.getString(\"contextConfig.defaultPosition\",\n                             \"\" + e.getLineNumber(),\n                             \"\" + e.getColumnNumber()));\n            ok = false;\n        } catch (Exception e) {\n            log.error(sm.getString(\"contextConfig.contextParse\",\n                    context.getName()), e);\n            ok = false;\n        } finally {\n            try {\n                if (stream != null) {\n                    stream.close();\n                }\n            } catch (IOException e) {\n                log.error(sm.getString(\"contextConfig.contextClose\"), e);\n            }\n        }\n    }\n\n\n    /**\n     * Adjust docBase.\n     * @throws IOException cannot access the context base path\n     */\n    protected void fixDocBase() throws IOException {\n\n        Host host = (Host) context.getParent();\n        File appBase = host.getAppBaseFile();\n\n        // This could be blank, relative, absolute or canonical\n        String docBaseConfigured = context.getDocBase();\n        // If there is no explicit docBase, derive it from the path and version\n        if (docBaseConfigured == null) {\n            // Trying to guess the docBase according to the path\n            String path = context.getPath();\n            if (path == null) {\n                return;\n            }\n            ContextName cn = new ContextName(path, context.getWebappVersion());\n            docBaseConfigured = cn.getBaseName();\n        }\n\n        // Obtain the absolute docBase in String and File form\n        String docBaseAbsolute;\n        File docBaseConfiguredFile = new File(docBaseConfigured);\n        if (!docBaseConfiguredFile.isAbsolute()) {\n            docBaseAbsolute = (new File(appBase, docBaseConfigured)).getAbsolutePath();\n        } else {\n            docBaseAbsolute = docBaseConfiguredFile.getAbsolutePath();\n        }\n        File docBaseAbsoluteFile = new File(docBaseAbsolute);\n        String originalDocBase = docBaseAbsolute;\n\n        ContextName cn = new ContextName(context.getPath(), context.getWebappVersion());\n        String pathName = cn.getBaseName();\n\n        boolean unpackWARs = true;\n        if (host instanceof StandardHost) {\n            unpackWARs = ((StandardHost) host).isUnpackWARs();\n            if (unpackWARs && context instanceof StandardContext) {\n                unpackWARs =  ((StandardContext) context).getUnpackWAR();\n            }\n        }\n\n        // At this point we need to determine if we have a WAR file in the\n        // appBase that needs to be expanded. Therefore we consider the absolute\n        // docBase NOT the canonical docBase. This is because some users symlink\n        // WAR files into the appBase and we want this to work correctly.\n        boolean docBaseAbsoluteInAppBase = docBaseAbsolute.startsWith(appBase.getPath() + File.separatorChar);\n        if (docBaseAbsolute.toLowerCase(Locale.ENGLISH).endsWith(\".war\") && !docBaseAbsoluteFile.isDirectory()) {\n            URL war = UriUtil.buildJarUrl(docBaseAbsoluteFile);\n            if (unpackWARs) {\n                docBaseAbsolute = ExpandWar.expand(host, war, pathName);\n                docBaseAbsoluteFile = new File(docBaseAbsolute);\n                if (context instanceof StandardContext) {\n                    ((StandardContext) context).setOriginalDocBase(originalDocBase);\n                }\n            } else {\n                ExpandWar.validate(host, war, pathName);\n            }\n        } else {\n            File docBaseAbsoluteFileWar = new File(docBaseAbsolute + \".war\");\n            URL war = null;\n            if (docBaseAbsoluteFileWar.exists() && docBaseAbsoluteInAppBase) {\n                war = UriUtil.buildJarUrl(docBaseAbsoluteFileWar);\n            }\n            if (docBaseAbsoluteFile.exists()) {\n                if (war != null && unpackWARs) {\n                    // Check if WAR needs to be re-expanded (e.g. if it has\n                    // changed). Note: HostConfig.deployWar() takes care of\n                    // ensuring that the correct XML file is used.\n                    // This will be a NO-OP if the WAR is unchanged.\n                    ExpandWar.expand(host, war, pathName);\n                }\n            } else {\n                if (war != null) {\n                    if (unpackWARs) {\n                        docBaseAbsolute = ExpandWar.expand(host, war, pathName);\n                        docBaseAbsoluteFile = new File(docBaseAbsolute);\n                    } else {\n                        docBaseAbsoluteFile = docBaseAbsoluteFileWar;\n                        ExpandWar.validate(host, war, pathName);\n                    }\n                }\n                if (context instanceof StandardContext) {\n                    ((StandardContext) context).setOriginalDocBase(originalDocBase);\n                }\n            }\n        }\n\n        String docBaseCanonical = docBaseAbsoluteFile.getCanonicalPath();\n\n        // Re-calculate now docBase is a canonical path\n        boolean docBaseCanonicalInAppBase =\n                docBaseAbsoluteFile.getCanonicalFile().toPath().startsWith(appBase.toPath());\n        String docBase;\n        if (docBaseCanonicalInAppBase) {\n            docBase = docBaseCanonical.substring(appBase.getPath().length());\n            docBase = docBase.replace(File.separatorChar, '/');\n            if (docBase.startsWith(\"/\")) {\n                docBase = docBase.substring(1);\n            }\n        } else {\n            docBase = docBaseCanonical.replace(File.separatorChar, '/');\n        }\n\n        context.setDocBase(docBase);\n    }\n\n\n    protected void antiLocking() {\n\n        if ((context instanceof StandardContext)\n                && ((StandardContext) context).getAntiResourceLocking()) {\n\n            Host host = (Host) context.getParent();\n            String docBase = context.getDocBase();\n            if (docBase == null) {\n                return;\n            }\n            originalDocBase = docBase;\n\n            File docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(host.getAppBaseFile(), docBase);\n            }\n\n            String path = context.getPath();\n            if (path == null) {\n                return;\n            }\n            ContextName cn = new ContextName(path, context.getWebappVersion());\n            docBase = cn.getBaseName();\n\n            String tmp = System.getProperty(\"java.io.tmpdir\");\n            File tmpFile = new File(tmp);\n            if (!tmpFile.isDirectory()) {\n                log.error(sm.getString(\"contextConfig.noAntiLocking\", tmp, context.getName()));\n                return;\n            }\n\n            if (originalDocBase.toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                antiLockingDocBase = new File(tmpFile, deploymentCount++ + \"-\" + docBase + \".war\");\n            } else {\n                antiLockingDocBase = new File(tmpFile, deploymentCount++ + \"-\" + docBase);\n            }\n            antiLockingDocBase = antiLockingDocBase.getAbsoluteFile();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Anti locking context[\" + context.getName()\n                        + \"] setting docBase to \" +\n                        antiLockingDocBase.getPath());\n            }\n\n            // Cleanup just in case an old deployment is lying around\n            ExpandWar.delete(antiLockingDocBase);\n            if (ExpandWar.copy(docBaseFile, antiLockingDocBase)) {\n                context.setDocBase(antiLockingDocBase.getPath());\n            }\n        }\n    }\n\n\n    /**\n     * Process a \"init\" event for this Context.\n     */\n    protected synchronized void init() {\n        // Called from StandardContext.init()\n\n        Digester contextDigester = null;\n        if (!getUseGeneratedCode()) {\n            contextDigester = createContextDigester();\n            contextDigester.getParser();\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.init\"));\n        }\n        context.setConfigured(false);\n        ok = true;\n\n        contextConfig(contextDigester);\n    }\n\n\n    /**\n     * Process a \"before start\" event for this Context.\n     */\n    protected synchronized void beforeStart() {\n\n        try {\n            fixDocBase();\n        } catch (IOException e) {\n            log.error(sm.getString(\n                    \"contextConfig.fixDocBase\", context.getName()), e);\n        }\n\n        antiLocking();\n    }\n\n\n    /**\n     * Process a \"contextConfig\" event for this Context.\n     */\n    protected synchronized void configureStart() {\n        // Called from StandardContext.start()\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.start\"));\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.xmlSettings\",\n                    context.getName(),\n                    Boolean.valueOf(context.getXmlValidation()),\n                    Boolean.valueOf(context.getXmlNamespaceAware())));\n        }\n\n        webConfig();\n\n        if (!context.getIgnoreAnnotations()) {\n            applicationAnnotationsConfig();\n        }\n        if (ok) {\n            validateSecurityRoles();\n        }\n\n        // Configure an authenticator if we need one\n        if (ok) {\n            authenticatorConfig();\n        }\n\n        // Dump the contents of this pipeline if requested\n        if (log.isDebugEnabled()) {\n            log.debug(\"Pipeline Configuration:\");\n            Pipeline pipeline = context.getPipeline();\n            Valve valves[] = null;\n            if (pipeline != null) {\n                valves = pipeline.getValves();\n            }\n            if (valves != null) {\n                for (Valve valve : valves) {\n                    log.debug(\"  \" + valve.getClass().getName());\n                }\n            }\n            log.debug(\"======================\");\n        }\n\n        // Make our application available if no problems were encountered\n        if (ok) {\n            context.setConfigured(true);\n        } else {\n            log.error(sm.getString(\"contextConfig.unavailable\"));\n            context.setConfigured(false);\n        }\n\n    }\n\n\n    /**\n     * Process a \"stop\" event for this Context.\n     */\n    protected synchronized void configureStop() {\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.stop\"));\n        }\n\n        int i;\n\n        // Removing children\n        Container[] children = context.findChildren();\n        for (i = 0; i < children.length; i++) {\n            context.removeChild(children[i]);\n        }\n\n        // Removing application parameters\n        /*\n        ApplicationParameter[] applicationParameters =\n            context.findApplicationParameters();\n        for (i = 0; i < applicationParameters.length; i++) {\n            context.removeApplicationParameter\n                (applicationParameters[i].getName());\n        }\n        */\n\n        // Removing security constraints\n        SecurityConstraint[] securityConstraints = context.findConstraints();\n        for (i = 0; i < securityConstraints.length; i++) {\n            context.removeConstraint(securityConstraints[i]);\n        }\n\n        // Removing errors pages\n        ErrorPage[] errorPages = context.findErrorPages();\n        for (i = 0; i < errorPages.length; i++) {\n            context.removeErrorPage(errorPages[i]);\n        }\n\n        // Removing filter defs\n        FilterDef[] filterDefs = context.findFilterDefs();\n        for (i = 0; i < filterDefs.length; i++) {\n            context.removeFilterDef(filterDefs[i]);\n        }\n\n        // Removing filter maps\n        FilterMap[] filterMaps = context.findFilterMaps();\n        for (i = 0; i < filterMaps.length; i++) {\n            context.removeFilterMap(filterMaps[i]);\n        }\n\n        // Removing Mime mappings\n        String[] mimeMappings = context.findMimeMappings();\n        for (i = 0; i < mimeMappings.length; i++) {\n            context.removeMimeMapping(mimeMappings[i]);\n        }\n\n        // Removing parameters\n        String[] parameters = context.findParameters();\n        for (i = 0; i < parameters.length; i++) {\n            context.removeParameter(parameters[i]);\n        }\n\n        // Removing security role\n        String[] securityRoles = context.findSecurityRoles();\n        for (i = 0; i < securityRoles.length; i++) {\n            context.removeSecurityRole(securityRoles[i]);\n        }\n\n        // Removing servlet mappings\n        String[] servletMappings = context.findServletMappings();\n        for (i = 0; i < servletMappings.length; i++) {\n            context.removeServletMapping(servletMappings[i]);\n        }\n\n        // Removing welcome files\n        String[] welcomeFiles = context.findWelcomeFiles();\n        for (i = 0; i < welcomeFiles.length; i++) {\n            context.removeWelcomeFile(welcomeFiles[i]);\n        }\n\n        // Removing wrapper lifecycles\n        String[] wrapperLifecycles = context.findWrapperLifecycles();\n        for (i = 0; i < wrapperLifecycles.length; i++) {\n            context.removeWrapperLifecycle(wrapperLifecycles[i]);\n        }\n\n        // Removing wrapper listeners\n        String[] wrapperListeners = context.findWrapperListeners();\n        for (i = 0; i < wrapperListeners.length; i++) {\n            context.removeWrapperListener(wrapperListeners[i]);\n        }\n\n        // Remove (partially) folders and files created by antiLocking\n        if (antiLockingDocBase != null) {\n            // No need to log failure - it is expected in this case\n            ExpandWar.delete(antiLockingDocBase, false);\n        }\n\n        // Reset ServletContextInitializer scanning\n        initializerClassMap.clear();\n        typeInitializerMap.clear();\n\n        ok = true;\n\n    }\n\n\n    /**\n     * Process a \"destroy\" event for this Context.\n     */\n    protected synchronized void destroy() {\n        // Called from StandardContext.destroy()\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.destroy\"));\n        }\n\n        // Skip clearing the work directory if Tomcat is being shutdown\n        Server s = getServer();\n        if (s != null && !s.getState().isAvailable()) {\n            return;\n        }\n\n        // Changed to getWorkPath per Bugzilla 35819.\n        if (context instanceof StandardContext) {\n            String workDir = ((StandardContext) context).getWorkPath();\n            if (workDir != null) {\n                ExpandWar.delete(new File(workDir));\n            }\n        }\n    }\n\n\n    private Server getServer() {\n        Container c = context;\n        while (c != null && !(c instanceof Engine)) {\n            c = c.getParent();\n        }\n\n        if (c == null) {\n            return null;\n        }\n\n        Service s = ((Engine)c).getService();\n\n        if (s == null) {\n            return null;\n        }\n\n        return s.getServer();\n    }\n\n    /**\n     * Validate the usage of security role names in the web application\n     * deployment descriptor.  If any problems are found, issue warning\n     * messages (for backwards compatibility) and add the missing roles.\n     * (To make these problems fatal instead, simply set the <code>ok</code>\n     * instance variable to <code>false</code> as well).\n     */\n    protected void validateSecurityRoles() {\n\n        // Check role names used in <security-constraint> elements\n        SecurityConstraint constraints[] = context.findConstraints();\n        for (SecurityConstraint constraint : constraints) {\n            String roles[] = constraint.findAuthRoles();\n            for (String role : roles) {\n                if (!\"*\".equals(role) &&\n                        !context.findSecurityRole(role)) {\n                    log.warn(sm.getString(\"contextConfig.role.auth\", role));\n                    context.addSecurityRole(role);\n                }\n            }\n        }\n\n        // Check role names used in <servlet> elements\n        Container wrappers[] = context.findChildren();\n        for (Container container : wrappers) {\n            Wrapper wrapper = (Wrapper) container;\n            String runAs = wrapper.getRunAs();\n            if ((runAs != null) && !context.findSecurityRole(runAs)) {\n                log.warn(sm.getString(\"contextConfig.role.runas\", runAs));\n                context.addSecurityRole(runAs);\n            }\n            String names[] = wrapper.findSecurityReferences();\n            for (String name : names) {\n                String link = wrapper.findSecurityReference(name);\n                if ((link != null) && !context.findSecurityRole(link)) {\n                    log.warn(sm.getString(\"contextConfig.role.link\", link));\n                    context.addSecurityRole(link);\n                }\n            }\n        }\n\n    }\n\n\n    protected File getHostConfigBase() {\n        File file = null;\n        if (context.getParent() instanceof Host) {\n            file = ((Host)context.getParent()).getConfigBaseFile();\n        }\n        return file;\n    }\n\n    /**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /*\n         * Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n\n        /*\n         * The rules for annotation scanning are not as clear-cut as one might\n         * think. Tomcat implements the following process:\n         * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of\n         *   which Servlet spec version is declared in web.xml. The EG has\n         *   confirmed this is the expected behaviour.\n         * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main\n         *   web.xml is marked as metadata-complete, JARs are still processed\n         *   for SCIs.\n         * - If metadata-complete=true and an absolute ordering is specified,\n         *   JARs excluded from the ordering are also excluded from the SCI\n         *   processing.\n         * - If an SCI has a @HandlesType annotation then all classes (except\n         *   those in JARs excluded from an absolute ordering) need to be\n         *   scanned to check if they match.\n         */\n        WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),\n                context.getXmlValidation(), context.getXmlBlockExternal());\n\n        Set<WebXml> defaults = new HashSet<>();\n        defaults.add(getDefaultWebXmlFragment(webXmlParser));\n\n        Set<WebXml> tomcatWebXml = new HashSet<>();\n        tomcatWebXml.add(getTomcatWebXmlFragment(webXmlParser));\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {\n            ok = false;\n        }\n\n        ServletContext sContext = context.getServletContext();\n\n        // Ordering is important here\n\n        // Step 1. Identify all the JARs packaged with the application and those\n        // provided by the container. If any of the application JARs have a\n        // web-fragment.xml it will be parsed at this point. web-fragment.xml\n        // files are ignored for container provided JARs.\n        Map<String,WebXml> fragments = processJarsForWebFragments(webXml, webXmlParser);\n\n        // Step 2. Order the fragments.\n        Set<WebXml> orderedFragments = null;\n        orderedFragments =\n                WebXml.orderWebFragments(webXml, fragments, sContext);\n\n        // Step 3. Look for ServletContainerInitializer implementations\n        if (ok) {\n            processServletContainerInitializers();\n        }\n\n        if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {\n            // Steps 4 & 5.\n            processClasses(webXml, orderedFragments);\n        }\n\n        if (!webXml.isMetadataComplete()) {\n            // Step 6. Merge web-fragment.xml files into the main web.xml\n            // file.\n            if (ok) {\n                ok = webXml.merge(orderedFragments);\n            }\n\n            // Step 7a\n            // merge tomcat-web.xml\n            webXml.merge(tomcatWebXml);\n\n            // Step 7b. Apply global defaults\n            // Have to merge defaults before JSP conversion since defaults\n            // provide JSP servlet definition.\n            webXml.merge(defaults);\n\n            // Step 8. Convert explicitly mentioned jsps to servlets\n            if (ok) {\n                convertJsps(webXml);\n            }\n\n            // Step 9. Apply merged web.xml to Context\n            if (ok) {\n                configureContext(webXml);\n            }\n        } else {\n            webXml.merge(tomcatWebXml);\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            configureContext(webXml);\n        }\n\n        if (context.getLogEffectiveWebXml()) {\n            log.info(sm.getString(\"contextConfig.effectiveWebXml\", webXml.toXml()));\n        }\n\n        // Always need to look for static resources\n        // Step 10. Look for static resources packaged in JARs\n        if (ok) {\n            // Spec does not define an order.\n            // Use ordered JARs followed by remaining JARs\n            Set<WebXml> resourceJars = new LinkedHashSet<>(orderedFragments);\n            for (WebXml fragment : fragments.values()) {\n                if (!resourceJars.contains(fragment)) {\n                    resourceJars.add(fragment);\n                }\n            }\n            processResourceJARs(resourceJars);\n            // See also StandardContext.resourcesStart() for\n            // WEB-INF/classes/META-INF/resources configuration\n        }\n\n        // Step 11. Apply the ServletContainerInitializer config to the\n        // context\n        if (ok) {\n            for (Map.Entry<ServletContainerInitializer,\n                    Set<Class<?>>> entry :\n                        initializerClassMap.entrySet()) {\n                if (entry.getValue().isEmpty()) {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), null);\n                } else {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }\n\n\n    protected void processClasses(WebXml webXml, Set<WebXml> orderedFragments) {\n        // Step 4. Process /WEB-INF/classes for annotations and\n        // @HandlesTypes matches\n\n        Map<String, JavaClassCacheEntry> javaClassCache;\n\n        if (context.getParallelAnnotationScanning()) {\n            javaClassCache = new ConcurrentHashMap<>();\n        } else {\n            javaClassCache = new HashMap<>();\n        }\n\n        if (ok) {\n            WebResource[] webResources =\n                    context.getResources().listResources(\"/WEB-INF/classes\");\n\n            for (WebResource webResource : webResources) {\n                // Skip the META-INF directory from any JARs that have been\n                // expanded in to WEB-INF/classes (sometimes IDEs do this).\n                if (\"META-INF\".equals(webResource.getName())) {\n                    continue;\n                }\n                processAnnotationsWebResource(webResource, webXml,\n                        webXml.isMetadataComplete(), javaClassCache);\n            }\n        }\n\n        // Step 5. Process JARs for annotations and\n        // @HandlesTypes matches - only need to process those fragments we\n        // are going to use (remember orderedFragments includes any\n        // container fragments)\n        if (ok) {\n            processAnnotations(\n                    orderedFragments, webXml.isMetadataComplete(), javaClassCache);\n        }\n\n        // Cache, if used, is no longer required so clear it\n        javaClassCache.clear();\n    }\n\n\n    private void configureContext(WebXml webxml) {\n        // As far as possible, process in alphabetical order so it is easy to\n        // check everything is present\n        // Some validation depends on correct public ID\n        context.setPublicId(webxml.getPublicId());\n\n        // Everything else in order\n        context.setEffectiveMajorVersion(webxml.getMajorVersion());\n        context.setEffectiveMinorVersion(webxml.getMinorVersion());\n\n        for (Entry<String, String> entry : webxml.getContextParams().entrySet()) {\n            context.addParameter(entry.getKey(), entry.getValue());\n        }\n        context.setDenyUncoveredHttpMethods(\n                webxml.getDenyUncoveredHttpMethods());\n        context.setDisplayName(webxml.getDisplayName());\n        context.setDistributable(webxml.isDistributable());\n        for (ContextLocalEjb ejbLocalRef : webxml.getEjbLocalRefs().values()) {\n            context.getNamingResources().addLocalEjb(ejbLocalRef);\n        }\n        for (ContextEjb ejbRef : webxml.getEjbRefs().values()) {\n            context.getNamingResources().addEjb(ejbRef);\n        }\n        for (ContextEnvironment environment : webxml.getEnvEntries().values()) {\n            context.getNamingResources().addEnvironment(environment);\n        }\n        for (ErrorPage errorPage : webxml.getErrorPages().values()) {\n            context.addErrorPage(errorPage);\n        }\n        for (FilterDef filter : webxml.getFilters().values()) {\n            if (filter.getAsyncSupported() == null) {\n                filter.setAsyncSupported(\"false\");\n            }\n            context.addFilterDef(filter);\n        }\n        for (FilterMap filterMap : webxml.getFilterMappings()) {\n            context.addFilterMap(filterMap);\n        }\n        context.setJspConfigDescriptor(webxml.getJspConfigDescriptor());\n        for (String listener : webxml.getListeners()) {\n            context.addApplicationListener(listener);\n        }\n        for (Entry<String, String> entry :\n                webxml.getLocaleEncodingMappings().entrySet()) {\n            context.addLocaleEncodingMappingParameter(entry.getKey(),\n                    entry.getValue());\n        }\n        // Prevents IAE\n        if (webxml.getLoginConfig() != null) {\n            context.setLoginConfig(webxml.getLoginConfig());\n        }\n        for (MessageDestinationRef mdr :\n                webxml.getMessageDestinationRefs().values()) {\n            context.getNamingResources().addMessageDestinationRef(mdr);\n        }\n\n        // messageDestinations were ignored in Tomcat 6, so ignore here\n\n        context.setMetadataComplete(webxml.isMetadataComplete());\n        for (Entry<String, String> entry :\n                webxml.getMimeMappings().entrySet()) {\n            context.addMimeMapping(entry.getKey(), entry.getValue());\n        }\n        context.setRequestCharacterEncoding(webxml.getRequestCharacterEncoding());\n        // Name is just used for ordering\n        for (ContextResourceEnvRef resource :\n                webxml.getResourceEnvRefs().values()) {\n            context.getNamingResources().addResourceEnvRef(resource);\n        }\n        for (ContextResource resource : webxml.getResourceRefs().values()) {\n            context.getNamingResources().addResource(resource);\n        }\n        context.setResponseCharacterEncoding(webxml.getResponseCharacterEncoding());\n        boolean allAuthenticatedUsersIsAppRole =\n                webxml.getSecurityRoles().contains(\n                        SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);\n        for (SecurityConstraint constraint : webxml.getSecurityConstraints()) {\n            if (allAuthenticatedUsersIsAppRole) {\n                constraint.treatAllAuthenticatedUsersAsApplicationRole();\n            }\n            context.addConstraint(constraint);\n        }\n        for (String role : webxml.getSecurityRoles()) {\n            context.addSecurityRole(role);\n        }\n        for (ContextService service : webxml.getServiceRefs().values()) {\n            context.getNamingResources().addService(service);\n        }\n        for (ServletDef servlet : webxml.getServlets().values()) {\n            Wrapper wrapper = context.createWrapper();\n            // Description is ignored\n            // Display name is ignored\n            // Icons are ignored\n\n            // jsp-file gets passed to the JSP Servlet as an init-param\n\n            if (servlet.getLoadOnStartup() != null) {\n                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());\n            }\n            if (servlet.getEnabled() != null) {\n                wrapper.setEnabled(servlet.getEnabled().booleanValue());\n            }\n            wrapper.setName(servlet.getServletName());\n            Map<String,String> params = servlet.getParameterMap();\n            for (Entry<String, String> entry : params.entrySet()) {\n                wrapper.addInitParameter(entry.getKey(), entry.getValue());\n            }\n            wrapper.setRunAs(servlet.getRunAs());\n            Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs();\n            for (SecurityRoleRef roleRef : roleRefs) {\n                wrapper.addSecurityReference(\n                        roleRef.getName(), roleRef.getLink());\n            }\n            wrapper.setServletClass(servlet.getServletClass());\n            MultipartDef multipartdef = servlet.getMultipartDef();\n            if (multipartdef != null) {\n                long maxFileSize = -1;\n                long maxRequestSize = -1;\n                int fileSizeThreshold = 0;\n\n                if(null != multipartdef.getMaxFileSize()) {\n                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());\n                }\n                if(null != multipartdef.getMaxRequestSize()) {\n                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());\n                }\n                if(null != multipartdef.getFileSizeThreshold()) {\n                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());\n                }\n\n                wrapper.setMultipartConfigElement(new MultipartConfigElement(\n                        multipartdef.getLocation(),\n                        maxFileSize,\n                        maxRequestSize,\n                        fileSizeThreshold));\n            }\n            if (servlet.getAsyncSupported() != null) {\n                wrapper.setAsyncSupported(\n                        servlet.getAsyncSupported().booleanValue());\n            }\n            wrapper.setOverridable(servlet.isOverridable());\n            context.addChild(wrapper);\n        }\n        for (Entry<String, String> entry :\n                webxml.getServletMappings().entrySet()) {\n            context.addServletMappingDecoded(entry.getKey(), entry.getValue());\n        }\n        SessionConfig sessionConfig = webxml.getSessionConfig();\n        if (sessionConfig != null) {\n            if (sessionConfig.getSessionTimeout() != null) {\n                context.setSessionTimeout(\n                        sessionConfig.getSessionTimeout().intValue());\n            }\n            SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig();\n            scc.setName(sessionConfig.getCookieName());\n            Map<String,String> attributes = sessionConfig.getCookieAttributes();\n            for (Map.Entry<String,String> attribute : attributes.entrySet()) {\n                scc.setAttribute(attribute.getKey(), attribute.getValue());\n            }\n            if (sessionConfig.getSessionTrackingModes().size() > 0) {\n                context.getServletContext().setSessionTrackingModes(\n                        sessionConfig.getSessionTrackingModes());\n            }\n        }\n\n        // Context doesn't use version directly\n\n        for (String welcomeFile : webxml.getWelcomeFiles()) {\n            /*\n             * The following will result in a welcome file of \"\" so don't add\n             * that to the context\n             * <welcome-file-list>\n             *   <welcome-file/>\n             * </welcome-file-list>\n             */\n            if (welcomeFile != null && welcomeFile.length() > 0) {\n                context.addWelcomeFile(welcomeFile);\n            }\n        }\n\n        // Do this last as it depends on servlets\n        for (JspPropertyGroup jspPropertyGroup :\n                webxml.getJspPropertyGroups()) {\n            String jspServletName = context.findServletMapping(\"*.jsp\");\n            if (jspServletName == null) {\n                jspServletName = \"jsp\";\n            }\n            if (context.findChild(jspServletName) != null) {\n                for (String urlPattern : jspPropertyGroup.getUrlPatterns()) {\n                    context.addServletMappingDecoded(urlPattern, jspServletName, true);\n                }\n            } else {\n                if(log.isDebugEnabled()) {\n                    for (String urlPattern : jspPropertyGroup.getUrlPatterns()) {\n                        log.debug(\"Skipping \" + urlPattern + \" , no servlet \" +\n                                jspServletName);\n                    }\n                }\n            }\n        }\n\n        for (Entry<String, String> entry :\n                webxml.getPostConstructMethods().entrySet()) {\n            context.addPostConstructMethod(entry.getKey(), entry.getValue());\n        }\n\n        for (Entry<String, String> entry :\n            webxml.getPreDestroyMethods().entrySet()) {\n            context.addPreDestroyMethod(entry.getKey(), entry.getValue());\n        }\n    }\n\n\n    private WebXml getTomcatWebXmlFragment(WebXmlParser webXmlParser) {\n\n        WebXml webXmlTomcatFragment = createWebXml();\n        webXmlTomcatFragment.setOverridable(true);\n\n        // Set to distributable else every app will be prevented from being\n        // distributable when the Tomcat fragment is merged with the main\n        // web.xml\n        webXmlTomcatFragment.setDistributable(true);\n        // When merging, the default welcome files are only used if the app has\n        // not defined any welcomes files.\n        webXmlTomcatFragment.setAlwaysAddWelcomeFiles(false);\n\n        WebResource resource = context.getResources().getResource(Constants.TomcatWebXml);\n        if (resource.isFile()) {\n            try {\n                InputSource source = new InputSource(resource.getURL().toURI().toString());\n                source.setByteStream(resource.getInputStream());\n                if (!webXmlParser.parseWebXml(source, webXmlTomcatFragment, false)) {\n                    ok = false;\n                }\n            } catch (URISyntaxException e) {\n                log.error(sm.getString(\"contextConfig.tomcatWebXmlError\"), e);\n            }\n        }\n        return webXmlTomcatFragment;\n    }\n\n\n    private WebXml getDefaultWebXmlFragment(WebXmlParser webXmlParser) {\n\n        // Host should never be null\n        Host host = (Host) context.getParent();\n\n        DefaultWebXmlCacheEntry entry = hostWebXmlCache.get(host);\n\n        InputSource globalWebXml = getGlobalWebXmlSource();\n        InputSource hostWebXml = getHostWebXmlSource();\n\n        long globalTimeStamp = 0;\n        long hostTimeStamp = 0;\n\n        if (globalWebXml != null) {\n            URLConnection uc = null;\n            try {\n                URI uri = new URI(globalWebXml.getSystemId());\n                URL url = uri.toURL();\n                uc = url.openConnection();\n                globalTimeStamp = uc.getLastModified();\n            } catch (IOException | URISyntaxException | IllegalArgumentException e) {\n                globalTimeStamp = -1;\n            } finally {\n                if (uc != null) {\n                    try {\n                        uc.getInputStream().close();\n                    } catch (IOException e) {\n                        ExceptionUtils.handleThrowable(e);\n                        globalTimeStamp = -1;\n                    }\n                }\n            }\n        }\n\n        if (hostWebXml != null) {\n            URLConnection uc = null;\n            try {\n                URI uri = new URI(hostWebXml.getSystemId());\n                URL url = uri.toURL();\n                uc = url.openConnection();\n                hostTimeStamp = uc.getLastModified();\n            } catch (IOException | URISyntaxException | IllegalArgumentException e) {\n                hostTimeStamp = -1;\n            } finally {\n                if (uc != null) {\n                    try {\n                        uc.getInputStream().close();\n                    } catch (IOException e) {\n                        ExceptionUtils.handleThrowable(e);\n                        hostTimeStamp = -1;\n                    }\n                }\n            }\n        }\n\n        if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                entry.getHostTimeStamp() == hostTimeStamp) {\n            InputSourceUtil.close(globalWebXml);\n            InputSourceUtil.close(hostWebXml);\n            return entry.getWebXml();\n        }\n\n        // Parsing global web.xml is relatively expensive. Use a sync block to\n        // make sure it only happens once. Use the pipeline since a lock will\n        // already be held on the host by another thread\n        synchronized (host.getPipeline()) {\n            entry = hostWebXmlCache.get(host);\n            if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                    entry.getHostTimeStamp() == hostTimeStamp) {\n                return entry.getWebXml();\n            }\n\n            WebXml webXmlDefaultFragment = createWebXml();\n            webXmlDefaultFragment.setOverridable(true);\n            // Set to distributable else every app will be prevented from being\n            // distributable when the default fragment is merged with the main\n            // web.xml\n            webXmlDefaultFragment.setDistributable(true);\n            // When merging, the default welcome files are only used if the app has\n            // not defined any welcomes files.\n            webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);\n\n            // Parse global web.xml if present\n            if (globalWebXml == null) {\n                // This is unusual enough to log\n                log.info(sm.getString(\"contextConfig.defaultMissing\"));\n            } else {\n                if (!webXmlParser.parseWebXml(\n                        globalWebXml, webXmlDefaultFragment, false)) {\n                    ok = false;\n                }\n            }\n\n            // Parse host level web.xml if present\n            // Additive apart from welcome pages\n            webXmlDefaultFragment.setReplaceWelcomeFiles(true);\n\n            if (!webXmlParser.parseWebXml(\n                    hostWebXml, webXmlDefaultFragment, false)) {\n                ok = false;\n            }\n\n            // Don't update the cache if an error occurs\n            if (globalTimeStamp != -1 && hostTimeStamp != -1) {\n                entry = new DefaultWebXmlCacheEntry(webXmlDefaultFragment,\n                        globalTimeStamp, hostTimeStamp);\n                hostWebXmlCache.put(host, entry);\n                // Add a Lifecycle listener to the Host that will remove it from\n                // the hostWebXmlCache once the Host is destroyed\n                host.addLifecycleListener(new HostWebXmlCacheCleaner());\n            }\n\n            return webXmlDefaultFragment;\n        }\n    }\n\n\n    private void convertJsps(WebXml webXml) {\n        Map<String,String> jspInitParams;\n        ServletDef jspServlet = webXml.getServlets().get(\"jsp\");\n        if (jspServlet == null) {\n            jspInitParams = new HashMap<>();\n            Wrapper w = (Wrapper) context.findChild(\"jsp\");\n            if (w != null) {\n                String[] params = w.findInitParameters();\n                for (String param : params) {\n                    jspInitParams.put(param, w.findInitParameter(param));\n                }\n            }\n        } else {\n            jspInitParams = jspServlet.getParameterMap();\n        }\n        for (ServletDef servletDef: webXml.getServlets().values()) {\n            if (servletDef.getJspFile() != null) {\n                convertJsp(servletDef, jspInitParams);\n            }\n        }\n    }\n\n    private void convertJsp(ServletDef servletDef,\n            Map<String,String> jspInitParams) {\n        servletDef.setServletClass(org.apache.catalina.core.Constants.JSP_SERVLET_CLASS);\n        String jspFile = servletDef.getJspFile();\n        if ((jspFile != null) && !jspFile.startsWith(\"/\")) {\n            if (context.isServlet22()) {\n                if(log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"contextConfig.jspFile.warning\",\n                                       jspFile));\n                }\n                jspFile = \"/\" + jspFile;\n            } else {\n                throw new IllegalArgumentException\n                    (sm.getString(\"contextConfig.jspFile.error\", jspFile));\n            }\n        }\n        servletDef.getParameterMap().put(\"jspFile\", jspFile);\n        servletDef.setJspFile(null);\n        for (Map.Entry<String, String> initParam: jspInitParams.entrySet()) {\n            servletDef.addInitParameter(initParam.getKey(), initParam.getValue());\n        }\n    }\n\n    protected WebXml createWebXml() {\n        return new WebXml();\n    }\n\n    /**\n     * Scan JARs for ServletContainerInitializer implementations.\n     */\n    protected void processServletContainerInitializers() {\n\n        List<ServletContainerInitializer> detectedScis;\n        try {\n            WebappServiceLoader<ServletContainerInitializer> loader = new WebappServiceLoader<>(context);\n            detectedScis = loader.load(ServletContainerInitializer.class);\n        } catch (IOException e) {\n            log.error(sm.getString(\n                    \"contextConfig.servletContainerInitializerFail\",\n                    context.getName()),\n                e);\n            ok = false;\n            return;\n        }\n\n        for (ServletContainerInitializer sci : detectedScis) {\n            initializerClassMap.put(sci, new HashSet<>());\n\n            HandlesTypes ht;\n            try {\n                ht = sci.getClass().getAnnotation(HandlesTypes.class);\n            } catch (Exception e) {\n                if (log.isDebugEnabled()) {\n                    log.info(sm.getString(\"contextConfig.sci.debug\",\n                            sci.getClass().getName()),\n                            e);\n                } else {\n                    log.info(sm.getString(\"contextConfig.sci.info\",\n                            sci.getClass().getName()));\n                }\n                continue;\n            }\n            if (ht == null) {\n                continue;\n            }\n            Class<?>[] types = ht.value();\n            if (types == null) {\n                continue;\n            }\n\n            for (Class<?> type : types) {\n                if (type.isAnnotation()) {\n                    handlesTypesAnnotations = true;\n                } else {\n                    handlesTypesNonAnnotations = true;\n                }\n                typeInitializerMap.computeIfAbsent(type, k -> new HashSet<>()).add(sci);\n            }\n        }\n    }\n\n\n    /**\n     * Scan JARs that contain web-fragment.xml files that will be used to\n     * configure this application to see if they also contain static resources.\n     * If static resources are found, add them to the context. Resources are\n     * added in web-fragment.xml priority order.\n     * @param fragments The set of fragments that will be scanned for\n     *  static resources\n     */\n    protected void processResourceJARs(Set<WebXml> fragments) {\n        for (WebXml fragment : fragments) {\n            URL url = fragment.getURL();\n            try {\n                if (\"jar\".equals(url.getProtocol()) || url.toString().endsWith(\".jar\")) {\n                    try (Jar jar = JarFactory.newInstance(url)) {\n                        jar.nextEntry();\n                        String entryName = jar.getEntryName();\n                        while (entryName != null) {\n                            if (entryName.startsWith(\"META-INF/resources/\")) {\n                                context.getResources().createWebResourceSet(\n                                        WebResourceRoot.ResourceSetType.RESOURCE_JAR,\n                                        \"/\", url, \"/META-INF/resources\");\n                                break;\n                            }\n                            jar.nextEntry();\n                            entryName = jar.getEntryName();\n                        }\n                    }\n                } else if (\"file\".equals(url.getProtocol())) {\n                    File file = new File(url.toURI());\n                    File resources = new File(file, \"META-INF/resources/\");\n                    if (resources.isDirectory()) {\n                        context.getResources().createWebResourceSet(\n                                WebResourceRoot.ResourceSetType.RESOURCE_JAR,\n                                \"/\", resources.getAbsolutePath(), null, \"/\");\n                    }\n                }\n            } catch (IOException | URISyntaxException e) {\n                log.error(sm.getString(\"contextConfig.resourceJarFail\", url,\n                        context.getName()));\n            }\n        }\n    }\n\n\n    /**\n     * Identify the default web.xml to be used and obtain an input source for\n     * it.\n     * @return an input source to the default web.xml\n     */\n    protected InputSource getGlobalWebXmlSource() {\n        // Is a default web.xml specified for the Context?\n        if (defaultWebXml == null && context instanceof StandardContext) {\n            defaultWebXml = ((StandardContext) context).getDefaultWebXml();\n        }\n        // Set the default if we don't have any overrides\n        if (defaultWebXml == null) {\n            getDefaultWebXml();\n        }\n\n        // Is it explicitly suppressed, e.g. in embedded environment?\n        if (Constants.NoDefaultWebXml.equals(defaultWebXml)) {\n            return null;\n        }\n        return getWebXmlSource(defaultWebXml, true);\n    }\n\n\n    /**\n     * Identify the host web.xml to be used and obtain an input source for\n     * it.\n     * @return an input source to the default per host web.xml\n     */\n    protected InputSource getHostWebXmlSource() {\n        File hostConfigBase = getHostConfigBase();\n        if (hostConfigBase == null) {\n            return null;\n        }\n\n        return getWebXmlSource(hostConfigBase.getPath(), false);\n    }\n\n    /**\n     * Identify the application web.xml to be used and obtain an input source\n     * for it.\n     * @return an input source to the context web.xml\n     */\n    protected InputSource getContextWebXmlSource() {\n        InputStream stream = null;\n        InputSource source = null;\n        URL url = null;\n\n        String altDDName = null;\n\n        // Open the application web.xml file, if it exists\n        ServletContext servletContext = context.getServletContext();\n        try {\n            if (servletContext != null) {\n                altDDName = (String)servletContext.getAttribute(Globals.ALT_DD_ATTR);\n                if (altDDName != null) {\n                    try {\n                        stream = new FileInputStream(altDDName);\n                        url = new File(altDDName).toURI().toURL();\n                    } catch (FileNotFoundException e) {\n                        log.error(sm.getString(\"contextConfig.altDDNotFound\",\n                                               altDDName));\n                    } catch (MalformedURLException e) {\n                        log.error(sm.getString(\"contextConfig.applicationUrl\"));\n                    }\n                } else {\n                    stream = servletContext.getResourceAsStream\n                        (Constants.ApplicationWebXml);\n                    try {\n                        url = servletContext.getResource(\n                                Constants.ApplicationWebXml);\n                    } catch (MalformedURLException e) {\n                        log.error(sm.getString(\"contextConfig.applicationUrl\"));\n                    }\n                }\n            }\n            if (stream == null || url == null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"contextConfig.applicationMissing\") + \" \" + context);\n                }\n            } else {\n                source = new InputSource(url.toExternalForm());\n                source.setByteStream(stream);\n            }\n        } finally {\n            if (source == null && stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        return source;\n    }\n\n    public String getConfigBasePath() {\n        String path = null;\n        if (context.getParent() instanceof Host) {\n            Host host = (Host) context.getParent();\n            if (host.getXmlBase() != null) {\n                path = host.getXmlBase();\n            } else {\n                StringBuilder xmlDir = new StringBuilder(\"conf\");\n                Container parent = host.getParent();\n                if (parent instanceof Engine) {\n                    xmlDir.append('/');\n                    xmlDir.append(parent.getName());\n                }\n                xmlDir.append('/');\n                xmlDir.append(host.getName());\n                path = xmlDir.toString();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Utility method to create an input source from the specified XML file.\n     * @param filename  Name of the file (possibly with one or more leading path\n     *                  segments) to read\n     * @param global true if processing a shared resource, false if processing\n     *        a host based resource\n     * @return the input source\n     */\n    protected InputSource getWebXmlSource(String filename, boolean global) {\n        ConfigurationSource.Resource webXmlResource = null;\n        try {\n            if (global) {\n                if (Constants.DefaultWebXml.equals(filename)) {\n                    webXmlResource = ConfigFileLoader.getSource().getSharedWebXml();\n                } else {\n                    webXmlResource = ConfigFileLoader.getSource().getResource(filename);\n                }\n            } else {\n                String hostWebXml = Container.getConfigPath(context, Constants.HostWebXml);\n                webXmlResource = ConfigFileLoader.getSource().getResource(hostWebXml);\n            }\n        } catch (IOException e) {\n            // Ignore if not found\n            return null;\n        }\n\n        InputStream stream = null;\n        InputSource source = null;\n\n        try {\n            stream = webXmlResource.getInputStream();\n            source = new InputSource(webXmlResource.getURI().toString());\n            if (stream != null) {\n                source.setByteStream(stream);\n            }\n        } catch (Exception e) {\n            log.error(sm.getString(\"contextConfig.defaultError\", filename, webXmlResource.getURI()), e);\n        } finally {\n            if (source == null && stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        return source;\n    }\n\n\n    /**\n     * Scan /WEB-INF/lib for JARs and for each one found add it and any\n     * /META-INF/web-fragment.xml to the resulting Map. web-fragment.xml files\n     * will be parsed before being added to the map. Every JAR will be added and\n     * <code>null</code> will be used if no web-fragment.xml was found. Any JARs\n     * known not contain fragments will be skipped.\n     *\n     * @param application The main web.xml metadata\n     * @param webXmlParser The parser to use to process the web.xml file\n     * @return A map of JAR name to processed web fragment (if any)\n     */\n    protected Map<String,WebXml> processJarsForWebFragments(WebXml application,\n            WebXmlParser webXmlParser) {\n\n        JarScanner jarScanner = context.getJarScanner();\n        boolean delegate = false;\n        if (context instanceof StandardContext) {\n            delegate = ((StandardContext) context).getDelegate();\n        }\n        boolean parseRequired = true;\n        Set<String> absoluteOrder = application.getAbsoluteOrdering();\n        if (absoluteOrder != null && absoluteOrder.isEmpty() &&\n                !context.getXmlValidation()) {\n            // Skip parsing when there is an empty absolute ordering and\n            // validation is not enabled\n            parseRequired = false;\n        }\n\n        FragmentJarScannerCallback callback =\n                new FragmentJarScannerCallback(webXmlParser, delegate, parseRequired);\n\n        jarScanner.scan(JarScanType.PLUGGABILITY,\n                context.getServletContext(), callback);\n\n        if (!callback.isOk()) {\n            ok = false;\n        }\n        return callback.getFragments();\n    }\n\n    protected void processAnnotations(Set<WebXml> fragments,\n            boolean handlesTypesOnly, Map<String, JavaClassCacheEntry> javaClassCache) {\n\n        if (context.getParallelAnnotationScanning()) {\n            processAnnotationsInParallel(fragments, handlesTypesOnly, javaClassCache);\n        } else {\n            for (WebXml fragment : fragments) {\n                scanWebXmlFragment(handlesTypesOnly, fragment, javaClassCache);\n            }\n        }\n    }\n\n    private void scanWebXmlFragment(boolean handlesTypesOnly, WebXml fragment, Map<String, JavaClassCacheEntry> javaClassCache) {\n\n        // Only need to scan for @HandlesTypes matches if any of the\n        // following are true:\n        // - it has already been determined only @HandlesTypes is required\n        //   (e.g. main web.xml has metadata-complete=\"true\"\n        // - this fragment is for a container JAR (Servlet 3.1 section 8.1)\n        // - this fragment has metadata-complete=\"true\"\n        boolean htOnly = handlesTypesOnly || !fragment.getWebappJar() ||\n                fragment.isMetadataComplete();\n\n        WebXml annotations = new WebXml();\n        // no impact on distributable\n        annotations.setDistributable(true);\n        URL url = fragment.getURL();\n        processAnnotationsUrl(url, annotations, htOnly, javaClassCache);\n        Set<WebXml> set = new HashSet<>();\n        set.add(annotations);\n        // Merge annotations into fragment - fragment takes priority\n        fragment.merge(set);\n    }\n\n    /**\n     * Executable task to scan a segment for annotations. Each task does the\n     * same work as the for loop inside processAnnotations();\n     */\n    private class AnnotationScanTask implements Runnable {\n        private final WebXml fragment;\n        private final boolean handlesTypesOnly;\n        private Map<String, JavaClassCacheEntry> javaClassCache;\n\n        private AnnotationScanTask(WebXml fragment, boolean handlesTypesOnly, Map<String, JavaClassCacheEntry> javaClassCache) {\n            this.fragment = fragment;\n            this.handlesTypesOnly = handlesTypesOnly;\n            this.javaClassCache = javaClassCache;\n        }\n\n        @Override\n        public void run() {\n            scanWebXmlFragment(handlesTypesOnly, fragment, javaClassCache);\n        }\n\n    }\n\n    /**\n     * Parallelized version of processAnnotationsInParallel(). Constructs tasks,\n     * submits them as they're created, then waits for completion.\n     *\n     * @param fragments        Set of parallelizable scans\n     * @param handlesTypesOnly Important parameter for the underlying scan\n     * @param javaClassCache The class cache\n     */\n    protected void processAnnotationsInParallel(Set<WebXml> fragments, boolean handlesTypesOnly,\n                                                Map<String, JavaClassCacheEntry> javaClassCache) {\n        Server s = getServer();\n        ExecutorService pool = (s == null) ? null : s.getUtilityExecutor();\n        if (pool != null) {\n            List<Future<?>> futures = new ArrayList<>(fragments.size());\n            for (WebXml fragment : fragments) {\n                Runnable task = new AnnotationScanTask(fragment, handlesTypesOnly, javaClassCache);\n                futures.add(pool.submit(task));\n            }\n            try {\n                for (Future<?> future : futures) {\n                    future.get();\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(sm.getString(\"contextConfig.processAnnotationsInParallelFailure\"), e);\n            }\n        } else {\n            // Fallback to regular processing\n            for (WebXml fragment : fragments) {\n                scanWebXmlFragment(handlesTypesOnly, fragment, javaClassCache);\n            }\n        }\n    }\n\n    protected void processAnnotationsWebResource(WebResource webResource,\n            WebXml fragment, boolean handlesTypesOnly,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        if (webResource.isDirectory()) {\n            WebResource[] webResources =\n                    webResource.getWebResourceRoot().listResources(\n                            webResource.getWebappPath());\n            if (webResources.length > 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsWebDir.debug\",\n                            webResource.getURL()));\n                }\n                for (WebResource r : webResources) {\n                    processAnnotationsWebResource(r, fragment, handlesTypesOnly, javaClassCache);\n                }\n            }\n        } else if (webResource.isFile() &&\n                webResource.getName().endsWith(\".class\")) {\n            try (InputStream is = webResource.getInputStream()) {\n                processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);\n            } catch (IOException | ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamWebResource\",\n                        webResource.getWebappPath()),e);\n            }\n        }\n    }\n\n\n    protected void processAnnotationsUrl(URL url, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (url == null) {\n            // Nothing to do.\n            return;\n        } else if (\"jar\".equals(url.getProtocol()) || url.toString().endsWith(\".jar\")) {\n            processAnnotationsJar(url, fragment, handlesTypesOnly, javaClassCache);\n        } else if (\"file\".equals(url.getProtocol())) {\n            try {\n                processAnnotationsFile(\n                        new File(url.toURI()), fragment, handlesTypesOnly, javaClassCache);\n            } catch (URISyntaxException e) {\n                log.error(sm.getString(\"contextConfig.fileUrl\", url), e);\n            }\n        } else {\n            log.error(sm.getString(\"contextConfig.unknownUrlProtocol\",\n                    url.getProtocol(), url));\n        }\n\n    }\n\n\n    protected void processAnnotationsJar(URL url, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        try (Jar jar = JarFactory.newInstance(url)) {\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"contextConfig.processAnnotationsJar.debug\", url));\n            }\n\n            jar.nextEntry();\n            String entryName = jar.getEntryName();\n            while (entryName != null) {\n                if (entryName.endsWith(\".class\")) {\n                    try (InputStream is = jar.getEntryInputStream()) {\n                        processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);\n                    } catch (IOException | ClassFormatException e) {\n                        log.error(sm.getString(\"contextConfig.inputStreamJar\",\n                                entryName, url),e);\n                    }\n                }\n                jar.nextEntry();\n                entryName = jar.getEntryName();\n            }\n        } catch (IOException e) {\n            log.error(sm.getString(\"contextConfig.jarFile\", url), e);\n        }\n    }\n\n\n    protected void processAnnotationsFile(File file, WebXml fragment,\n            boolean handlesTypesOnly, Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        if (file.isDirectory()) {\n            // Returns null if directory is not readable\n            String[] dirs = file.list();\n            if (dirs != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"contextConfig.processAnnotationsDir.debug\", file));\n                }\n                for (String dir : dirs) {\n                    processAnnotationsFile(\n                            new File(file,dir), fragment, handlesTypesOnly, javaClassCache);\n                }\n            }\n        } else if (file.getName().endsWith(\".class\") && file.canRead()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                processAnnotationsStream(fis, fragment, handlesTypesOnly, javaClassCache);\n            } catch (IOException | ClassFormatException e) {\n                log.error(sm.getString(\"contextConfig.inputStreamFile\",\n                        file.getAbsolutePath()),e);\n            }\n        }\n    }\n\n    \n    "{=)(=}"\n\n\n    protected void processClass(WebXml fragment, JavaClass clazz) {\n        AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();\n        if (annotationsEntries != null) {\n            String className = clazz.getClassName();\n            for (AnnotationEntry ae : annotationsEntries) {\n                String type = ae.getAnnotationType();\n                if (\"Ljakarta/servlet/annotation/WebServlet;\".equals(type)) {\n                    processAnnotationWebServlet(className, ae, fragment);\n                }else if (\"Ljakarta/servlet/annotation/WebFilter;\".equals(type)) {\n                    processAnnotationWebFilter(className, ae, fragment);\n                }else if (\"Ljakarta/servlet/annotation/WebListener;\".equals(type)) {\n                    fragment.addListener(className);\n                } else {\n                    // Unknown annotation - ignore\n                }\n            }\n        }\n    }\n\n\n    /**\n     * For classes packaged with the web application, the class and each\n     * super class needs to be checked for a match with {@link HandlesTypes} or\n     * for an annotation that matches {@link HandlesTypes}.\n     * @param javaClass the class to check\n     * @param javaClassCache a class cache\n     */\n    protected void checkHandlesTypes(JavaClass javaClass,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n\n        // Skip this if we can\n        if (typeInitializerMap.size() == 0) {\n            return;\n        }\n\n        if ((javaClass.getAccessFlags() &\n                org.apache.tomcat.util.bcel.Const.ACC_ANNOTATION) != 0) {\n            // Skip annotations.\n            return;\n        }\n\n        String className = javaClass.getClassName();\n\n        Class<?> clazz = null;\n        if (handlesTypesNonAnnotations) {\n            // This *might* be match for a HandlesType.\n            populateJavaClassCache(className, javaClass, javaClassCache);\n            JavaClassCacheEntry entry = javaClassCache.get(className);\n            if (entry.getSciSet() == null) {\n                try {\n                    populateSCIsForCacheEntry(entry, javaClassCache);\n                } catch (StackOverflowError soe) {\n                    throw new IllegalStateException(sm.getString(\n                            \"contextConfig.annotationsStackOverflow\",\n                            context.getName(),\n                            classHierarchyToString(className, entry, javaClassCache)));\n                }\n            }\n            if (!entry.getSciSet().isEmpty()) {\n                // Need to try and load the class\n                clazz = Introspection.loadClass(context, className);\n                if (clazz == null) {\n                    // Can't load the class so no point continuing\n                    return;\n                }\n\n                for (ServletContainerInitializer sci : entry.getSciSet()) {\n                    Set<Class<?>> classes = initializerClassMap.computeIfAbsent(sci, k -> new HashSet<>());\n                    classes.add(clazz);\n                }\n            }\n        }\n\n        if (handlesTypesAnnotations) {\n            AnnotationEntry[] annotationEntries = javaClass.getAllAnnotationEntries();\n            if (annotationEntries != null) {\n                for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :\n                        typeInitializerMap.entrySet()) {\n                    if (entry.getKey().isAnnotation()) {\n                        String entryClassName = entry.getKey().getName();\n                        for (AnnotationEntry annotationEntry : annotationEntries) {\n                            if (entryClassName.equals(\n                                    getClassName(annotationEntry.getAnnotationType()))) {\n                                if (clazz == null) {\n                                    clazz = Introspection.loadClass(\n                                            context, className);\n                                    if (clazz == null) {\n                                        // Can't load the class so no point\n                                        // continuing\n                                        return;\n                                    }\n                                }\n                                for (ServletContainerInitializer sci : entry.getValue()) {\n                                    initializerClassMap.get(sci).add(clazz);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    private String classHierarchyToString(String className,\n            JavaClassCacheEntry entry, Map<String,JavaClassCacheEntry> javaClassCache) {\n        JavaClassCacheEntry start = entry;\n        StringBuilder msg = new StringBuilder(className);\n        msg.append(\"->\");\n\n        String parentName = entry.getSuperclassName();\n        JavaClassCacheEntry parent = javaClassCache.get(parentName);\n        int count = 0;\n\n        while (count < 100 && parent != null && parent != start) {\n            msg.append(parentName);\n            msg.append(\"->\");\n\n            count ++;\n            parentName = parent.getSuperclassName();\n            parent = javaClassCache.get(parentName);\n        }\n\n        msg.append(parentName);\n\n        return msg.toString();\n    }\n\n    private void populateJavaClassCache(String className, JavaClass javaClass,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (javaClassCache.containsKey(className)) {\n            return;\n        }\n\n        // Add this class to the cache\n        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));\n\n        populateJavaClassCache(javaClass.getSuperclassName(), javaClassCache);\n\n        for (String interfaceName : javaClass.getInterfaceNames()) {\n            populateJavaClassCache(interfaceName, javaClassCache);\n        }\n    }\n\n    private void populateJavaClassCache(String className,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        if (!javaClassCache.containsKey(className)) {\n            String name = className.replace('.', '/') + \".class\";\n            try (InputStream is = context.getLoader().getClassLoader().getResourceAsStream(name)) {\n                if (is == null) {\n                    return;\n                }\n                ClassParser parser = new ClassParser(is);\n                JavaClass clazz = parser.parse();\n                populateJavaClassCache(clazz.getClassName(), clazz, javaClassCache);\n            } catch (ClassFormatException | IOException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            }\n        }\n    }\n\n    private void populateSCIsForCacheEntry(JavaClassCacheEntry cacheEntry,\n            Map<String,JavaClassCacheEntry> javaClassCache) {\n        Set<ServletContainerInitializer> result = new HashSet<>();\n\n        // Super class\n        String superClassName = cacheEntry.getSuperclassName();\n        JavaClassCacheEntry superClassCacheEntry =\n                javaClassCache.get(superClassName);\n\n        // Avoid an infinite loop with java.lang.Object\n        if (cacheEntry.equals(superClassCacheEntry)) {\n            cacheEntry.setSciSet(EMPTY_SCI_SET);\n            return;\n        }\n\n        // May be null of the class is not present or could not be loaded.\n        if (superClassCacheEntry != null) {\n            if (superClassCacheEntry.getSciSet() == null) {\n                populateSCIsForCacheEntry(superClassCacheEntry, javaClassCache);\n            }\n            result.addAll(superClassCacheEntry.getSciSet());\n        }\n        result.addAll(getSCIsForClass(superClassName));\n\n        // Interfaces\n        for (String interfaceName : cacheEntry.getInterfaceNames()) {\n            JavaClassCacheEntry interfaceEntry =\n                    javaClassCache.get(interfaceName);\n            // A null could mean that the class not present in application or\n            // that there is nothing of interest. Either way, nothing to do here\n            // so move along\n            if (interfaceEntry != null) {\n                if (interfaceEntry.getSciSet() == null) {\n                    populateSCIsForCacheEntry(interfaceEntry, javaClassCache);\n                }\n                result.addAll(interfaceEntry.getSciSet());\n            }\n            result.addAll(getSCIsForClass(interfaceName));\n        }\n\n        cacheEntry.setSciSet(result.isEmpty() ? EMPTY_SCI_SET : result);\n    }\n\n    private Set<ServletContainerInitializer> getSCIsForClass(String className) {\n        for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :\n                typeInitializerMap.entrySet()) {\n            Class<?> clazz = entry.getKey();\n            if (!clazz.isAnnotation()) {\n                if (clazz.getName().equals(className)) {\n                    return entry.getValue();\n                }\n            }\n        }\n        return EMPTY_SCI_SET;\n    }\n\n    private static String getClassName(String internalForm) {\n        if (!internalForm.startsWith(\"L\")) {\n            return internalForm;\n        }\n\n        // Assume starts with L, ends with ; and uses / rather than .\n        return internalForm.substring(1,\n                internalForm.length() - 1).replace('/', '.');\n    }\n\n    protected void processAnnotationWebServlet(String className,\n            AnnotationEntry ae, WebXml fragment) {\n        String servletName = null;\n        // must search for name s. Spec Servlet API 3.0 - 8.2.3.3.n.ii page 81\n        List<ElementValuePair> evps = ae.getElementValuePairs();\n        for (ElementValuePair evp : evps) {\n            String name = evp.getNameString();\n            if (\"name\".equals(name)) {\n                servletName = evp.getValue().stringifyValue();\n                break;\n            }\n        }\n        if (servletName == null) {\n            // classname is default servletName as annotation has no name!\n            servletName = className;\n        }\n        ServletDef servletDef = fragment.getServlets().get(servletName);\n\n        boolean isWebXMLservletDef;\n        if (servletDef == null) {\n            servletDef = new ServletDef();\n            servletDef.setServletName(servletName);\n            servletDef.setServletClass(className);\n            isWebXMLservletDef = false;\n        } else {\n            isWebXMLservletDef = true;\n        }\n\n        boolean urlPatternsSet = false;\n        String[] urlPatterns = null;\n\n        // List<ElementValuePair> evps = ae.getElementValuePairs();\n        for (ElementValuePair evp : evps) {\n            String name = evp.getNameString();\n            if (\"value\".equals(name) || \"urlPatterns\".equals(name)) {\n                if (urlPatternsSet) {\n                    throw new IllegalArgumentException(sm.getString(\n                            \"contextConfig.urlPatternValue\", \"WebServlet\", className));\n                }\n                urlPatternsSet = true;\n                urlPatterns = processAnnotationsStringArray(evp.getValue());\n            } else if (\"description\".equals(name)) {\n                if (servletDef.getDescription() == null) {\n                    servletDef.setDescription(evp.getValue().stringifyValue());\n                }\n            } else if (\"displayName\".equals(name)) {\n                if (servletDef.getDisplayName() == null) {\n                    servletDef.setDisplayName(evp.getValue().stringifyValue());\n                }\n            } else if (\"largeIcon\".equals(name)) {\n                if (servletDef.getLargeIcon() == null) {\n                    servletDef.setLargeIcon(evp.getValue().stringifyValue());\n                }\n            } else if (\"smallIcon\".equals(name)) {\n                if (servletDef.getSmallIcon() == null) {\n                    servletDef.setSmallIcon(evp.getValue().stringifyValue());\n                }\n            } else if (\"asyncSupported\".equals(name)) {\n                if (servletDef.getAsyncSupported() == null) {\n                    servletDef.setAsyncSupported(evp.getValue()\n                            .stringifyValue());\n                }\n            } else if (\"loadOnStartup\".equals(name)) {\n                if (servletDef.getLoadOnStartup() == null) {\n                    servletDef\n                            .setLoadOnStartup(evp.getValue().stringifyValue());\n                }\n            } else if (\"initParams\".equals(name)) {\n                Map<String, String> initParams = processAnnotationWebInitParams(evp\n                        .getValue());\n                if (isWebXMLservletDef) {\n                    Map<String, String> webXMLInitParams = servletDef\n                            .getParameterMap();\n                    for (Map.Entry<String, String> entry : initParams\n                            .entrySet()) {\n                        if (webXMLInitParams.get(entry.getKey()) == null) {\n                            servletDef.addInitParameter(entry.getKey(), entry\n                                    .getValue());\n                        }\n                    }\n                } else {\n                    for (Map.Entry<String, String> entry : initParams\n                            .entrySet()) {\n                        servletDef.addInitParameter(entry.getKey(), entry\n                                .getValue());\n                    }\n                }\n            }\n        }\n        if (!isWebXMLservletDef && urlPatterns != null) {\n            fragment.addServlet(servletDef);\n        }\n        if (urlPatterns != null) {\n            if (!fragment.getServletMappings().containsValue(servletName)) {\n                for (String urlPattern : urlPatterns) {\n                    fragment.addServletMapping(urlPattern, servletName);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * process filter annotation and merge with existing one!\n     * FIXME: refactoring method too long and has redundant subroutines with\n     *        processAnnotationWebServlet!\n     * @param className The filter class name\n     * @param ae The filter annotation\n     * @param fragment The corresponding fragment\n     */\n    protected void processAnnotationWebFilter(String className,\n            AnnotationEntry ae, WebXml fragment) {\n        String filterName = null;\n        // must search for name s. Spec Servlet API 3.0 - 8.2.3.3.n.ii page 81\n        List<ElementValuePair> evps = ae.getElementValuePairs();\n        for (ElementValuePair evp : evps) {\n            String name = evp.getNameString();\n            if (\"filterName\".equals(name)) {\n                filterName = evp.getValue().stringifyValue();\n                break;\n            }\n        }\n        if (filterName == null) {\n            // classname is default filterName as annotation has no name!\n            filterName = className;\n        }\n        FilterDef filterDef = fragment.getFilters().get(filterName);\n        FilterMap filterMap = new FilterMap();\n\n        boolean isWebXMLfilterDef;\n        if (filterDef == null) {\n            filterDef = new FilterDef();\n            filterDef.setFilterName(filterName);\n            filterDef.setFilterClass(className);\n            isWebXMLfilterDef = false;\n        } else {\n            isWebXMLfilterDef = true;\n        }\n\n        boolean urlPatternsSet = false;\n        boolean servletNamesSet = false;\n        boolean dispatchTypesSet = false;\n        String[] urlPatterns = null;\n\n        for (ElementValuePair evp : evps) {\n            String name = evp.getNameString();\n            if (\"value\".equals(name) || \"urlPatterns\".equals(name)) {\n                if (urlPatternsSet) {\n                    throw new IllegalArgumentException(sm.getString(\n                            \"contextConfig.urlPatternValue\", \"WebFilter\", className));\n                }\n                urlPatterns = processAnnotationsStringArray(evp.getValue());\n                urlPatternsSet = urlPatterns.length > 0;\n                for (String urlPattern : urlPatterns) {\n                    // % decoded (if required) using UTF-8\n                    filterMap.addURLPattern(urlPattern);\n                }\n            } else if (\"servletNames\".equals(name)) {\n                String[] servletNames = processAnnotationsStringArray(evp\n                        .getValue());\n                servletNamesSet = servletNames.length > 0;\n                for (String servletName : servletNames) {\n                    filterMap.addServletName(servletName);\n                }\n            } else if (\"dispatcherTypes\".equals(name)) {\n                String[] dispatcherTypes = processAnnotationsStringArray(evp\n                        .getValue());\n                dispatchTypesSet = dispatcherTypes.length > 0;\n                for (String dispatcherType : dispatcherTypes) {\n                    filterMap.setDispatcher(dispatcherType);\n                }\n            } else if (\"description\".equals(name)) {\n                if (filterDef.getDescription() == null) {\n                    filterDef.setDescription(evp.getValue().stringifyValue());\n                }\n            } else if (\"displayName\".equals(name)) {\n                if (filterDef.getDisplayName() == null) {\n                    filterDef.setDisplayName(evp.getValue().stringifyValue());\n                }\n            } else if (\"largeIcon\".equals(name)) {\n                if (filterDef.getLargeIcon() == null) {\n                    filterDef.setLargeIcon(evp.getValue().stringifyValue());\n                }\n            } else if (\"smallIcon\".equals(name)) {\n                if (filterDef.getSmallIcon() == null) {\n                    filterDef.setSmallIcon(evp.getValue().stringifyValue());\n                }\n            } else if (\"asyncSupported\".equals(name)) {\n                if (filterDef.getAsyncSupported() == null) {\n                    filterDef\n                            .setAsyncSupported(evp.getValue().stringifyValue());\n                }\n            } else if (\"initParams\".equals(name)) {\n                Map<String, String> initParams = processAnnotationWebInitParams(evp\n                        .getValue());\n                if (isWebXMLfilterDef) {\n                    Map<String, String> webXMLInitParams = filterDef\n                            .getParameterMap();\n                    for (Map.Entry<String, String> entry : initParams\n                            .entrySet()) {\n                        if (webXMLInitParams.get(entry.getKey()) == null) {\n                            filterDef.addInitParameter(entry.getKey(), entry\n                                    .getValue());\n                        }\n                    }\n                } else {\n                    for (Map.Entry<String, String> entry : initParams\n                            .entrySet()) {\n                        filterDef.addInitParameter(entry.getKey(), entry\n                                .getValue());\n                    }\n                }\n\n            }\n        }\n        if (!isWebXMLfilterDef) {\n            fragment.addFilter(filterDef);\n            if (urlPatternsSet || servletNamesSet) {\n                filterMap.setFilterName(filterName);\n                fragment.addFilterMapping(filterMap);\n            }\n        }\n        if (urlPatternsSet || dispatchTypesSet) {\n            Set<FilterMap> fmap = fragment.getFilterMappings();\n            FilterMap descMap = null;\n            for (FilterMap map : fmap) {\n                if (filterName.equals(map.getFilterName())) {\n                    descMap = map;\n                    break;\n                }\n            }\n            if (descMap != null) {\n                String[] urlsPatterns = descMap.getURLPatterns();\n                if (urlPatternsSet\n                        && (urlsPatterns == null || urlsPatterns.length == 0)) {\n                    for (String urlPattern : filterMap.getURLPatterns()) {\n                        // % decoded (if required) using UTF-8\n                        descMap.addURLPattern(urlPattern);\n                    }\n                }\n                String[] dispatcherNames = descMap.getDispatcherNames();\n                if (dispatchTypesSet\n                        && (dispatcherNames == null || dispatcherNames.length == 0)) {\n                    for (String dis : filterMap.getDispatcherNames()) {\n                        descMap.setDispatcher(dis);\n                    }\n                }\n            }\n        }\n\n    }\n\n    protected String[] processAnnotationsStringArray(ElementValue ev) {\n        List<String> values = new ArrayList<>();\n        if (ev instanceof ArrayElementValue) {\n            ElementValue[] arrayValues =\n                ((ArrayElementValue) ev).getElementValuesArray();\n            for (ElementValue value : arrayValues) {\n                values.add(value.stringifyValue());\n            }\n        } else {\n            values.add(ev.stringifyValue());\n        }\n        return values.toArray(new String[0]);\n    }\n\n    protected Map<String,String> processAnnotationWebInitParams(\n            ElementValue ev) {\n        Map<String, String> result = new HashMap<>();\n        if (ev instanceof ArrayElementValue) {\n            ElementValue[] arrayValues =\n                ((ArrayElementValue) ev).getElementValuesArray();\n            for (ElementValue value : arrayValues) {\n                if (value instanceof AnnotationElementValue) {\n                    List<ElementValuePair> evps = ((AnnotationElementValue) value)\n                            .getAnnotationEntry().getElementValuePairs();\n                    String initParamName = null;\n                    String initParamValue = null;\n                    for (ElementValuePair evp : evps) {\n                        if (\"name\".equals(evp.getNameString())) {\n                            initParamName = evp.getValue().stringifyValue();\n                        } else if (\"value\".equals(evp.getNameString())) {\n                            initParamValue = evp.getValue().stringifyValue();\n                        } else {\n                            // Ignore\n                        }\n                    }\n                    result.put(initParamName, initParamValue);\n                }\n            }\n        }\n        return result;\n    }\n\n    private static class DefaultWebXmlCacheEntry {\n        private final WebXml webXml;\n        private final long globalTimeStamp;\n        private final long hostTimeStamp;\n\n        DefaultWebXmlCacheEntry(WebXml webXml, long globalTimeStamp,\n                long hostTimeStamp) {\n            this.webXml = webXml;\n            this.globalTimeStamp = globalTimeStamp;\n            this.hostTimeStamp = hostTimeStamp;\n        }\n\n        public WebXml getWebXml() {\n            return webXml;\n        }\n\n        public long getGlobalTimeStamp() {\n            return globalTimeStamp;\n        }\n\n        public long getHostTimeStamp() {\n            return hostTimeStamp;\n        }\n    }\n\n    private static class HostWebXmlCacheCleaner implements LifecycleListener {\n\n        @Override\n        public void lifecycleEvent(LifecycleEvent event) {\n\n            if (Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) {\n                Host host = (Host) event.getSource();\n                hostWebXmlCache.remove(host);\n            }\n        }\n    }\n\n    static class JavaClassCacheEntry {\n        public final String superclassName;\n\n        public final String[] interfaceNames;\n\n        private Set<ServletContainerInitializer> sciSet = null;\n\n        JavaClassCacheEntry(JavaClass javaClass) {\n            superclassName = javaClass.getSuperclassName();\n            interfaceNames = javaClass.getInterfaceNames();\n        }\n\n        public String getSuperclassName() {\n            return superclassName;\n        }\n\n        public String[] getInterfaceNames() {\n            return interfaceNames;\n        }\n\n        public Set<ServletContainerInitializer> getSciSet() {\n            return sciSet;\n        }\n\n        public void setSciSet(Set<ServletContainerInitializer> sciSet) {\n            this.sciSet = sciSet;\n        }\n    }\n}\n"{=)(=}C%3A%2FUsers%2FEDY%2FIdeaProjects%2Ftomcat-main